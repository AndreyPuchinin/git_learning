= git stash

Рассмотрим ситуацию. У нас есть две ветви, в каждой из которых числится хотя бы один коммит. Пусть мы 

* работаем в *ветви 2*
* имеем что-то в *stage*
* и хотим переместиться ("перебранчеваться") на **ветку 1**.

Для такого перемещения *git* попросит закоммитить то, что находится в *stage* *ветви 2* или удалить эти данные. Но есть и третий вариант...

*_stash_*  --  позволяет "припрятать" измененияв *stage* *ветви* (в данном случае *ветви 2*), а потом восстановить их обратно.

Важно понимать, что *_stash list_*  --  это "коллекция" (__как бы она ни была представлена внутри__). Из этой "коллекции" можно что-то достать или можно в неё что-то положить. Сама "коллекция" в принципе не обязана помнить, откуда к ней пришли данные (но помнит - см. картинку ниже). Это значит, что достать из неё можно любые данные и потом что-угодно с ними сделать  --  например, вернуть в рабочую директорию какой-то ветки. В конце концов, ветка не обязана быть _той же_, из которой прятались данные.

image::remember.PNG[]

*_stash apply_*  --  возвращает данные в рабочую диркторию, но отавляет их в припрятанной "коллекции". По умолчанию возвращается последние данные, но можно принудительно указать их с помощью *_stash apply stash@{№}_

Чтобы вернуть данные в *stage*, используется *_stash apply --indec_*

*_git stash drop_*  --  для того, чтобы при*_stash apply_* восстанавливаемые данные, удалились из припрятанной "коллеции"

Также можно использовать *_git stash pop_*

